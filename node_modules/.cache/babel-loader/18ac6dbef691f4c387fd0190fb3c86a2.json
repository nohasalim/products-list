{"ast":null,"code":"'use strict';\n\nvar globalThis = require('../internals/global-this');\n\nvar apply = require('../internals/function-apply');\n\nvar uncurryThis = require('../internals/function-uncurry-this-clause');\n\nvar isCallable = require('../internals/is-callable');\n\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\n\nvar isForced = require('../internals/is-forced');\n\nvar path = require('../internals/path');\n\nvar bind = require('../internals/function-bind-context');\n\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\n\nvar hasOwn = require('../internals/has-own-property'); // add debugging info\n\n\nrequire('../internals/shared-store');\n\nvar wrapConstructor = function (NativeConstructor) {\n  var Wrapper = function (a, b, c) {\n    if (this instanceof Wrapper) {\n      switch (arguments.length) {\n        case 0:\n          return new NativeConstructor();\n\n        case 1:\n          return new NativeConstructor(a);\n\n        case 2:\n          return new NativeConstructor(a, b);\n      }\n\n      return new NativeConstructor(a, b, c);\n    }\n\n    return apply(NativeConstructor, this, arguments);\n  };\n\n  Wrapper.prototype = NativeConstructor.prototype;\n  return Wrapper;\n};\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\n\n\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var PROTO = options.proto;\n  var nativeSource = GLOBAL ? globalThis : STATIC ? globalThis[TARGET] : globalThis[TARGET] && globalThis[TARGET].prototype;\n  var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];\n  var targetPrototype = target.prototype;\n  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;\n  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;\n\n  for (key in source) {\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contains in native\n\n    USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);\n    targetProperty = target[key];\n    if (USE_NATIVE) if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(nativeSource, key);\n      nativeProperty = descriptor && descriptor.value;\n    } else nativeProperty = nativeSource[key]; // export native or implementation\n\n    sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];\n    if (!FORCED && !PROTO && typeof targetProperty == typeof sourceProperty) continue; // bind methods to global for calling from export context\n\n    if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, globalThis); // wrap global constructors for prevent changes in this version\n    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty); // make static versions for prototype methods\n    else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty); // default case\n    else resultProperty = sourceProperty; // add a flag to not completely full polyfills\n\n    if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {\n      createNonEnumerableProperty(resultProperty, 'sham', true);\n    }\n\n    createNonEnumerableProperty(target, key, resultProperty);\n\n    if (PROTO) {\n      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';\n\n      if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {\n        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});\n      } // export virtual prototype methods\n\n\n      createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty); // export real prototype methods\n\n      if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {\n        createNonEnumerableProperty(targetPrototype, key, sourceProperty);\n      }\n    }\n  }\n};","map":{"version":3,"sources":["D:/products-list/node_modules/core-js-pure/internals/export.js"],"names":["globalThis","require","apply","uncurryThis","isCallable","getOwnPropertyDescriptor","f","isForced","path","bind","createNonEnumerableProperty","hasOwn","wrapConstructor","NativeConstructor","Wrapper","a","b","c","arguments","length","prototype","module","exports","options","source","TARGET","target","GLOBAL","global","STATIC","stat","PROTO","proto","nativeSource","targetPrototype","FORCED","USE_NATIVE","VIRTUAL_PROTOTYPE","key","sourceProperty","targetProperty","nativeProperty","resultProperty","descriptor","forced","dontCallGetSet","value","wrap","sham","real"],"mappings":"AAAA;;AACA,IAAIA,UAAU,GAAGC,OAAO,CAAC,0BAAD,CAAxB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,6BAAD,CAAnB;;AACA,IAAIE,WAAW,GAAGF,OAAO,CAAC,2CAAD,CAAzB;;AACA,IAAIG,UAAU,GAAGH,OAAO,CAAC,0BAAD,CAAxB;;AACA,IAAII,wBAAwB,GAAGJ,OAAO,CAAC,iDAAD,CAAP,CAA2DK,CAA1F;;AACA,IAAIC,QAAQ,GAAGN,OAAO,CAAC,wBAAD,CAAtB;;AACA,IAAIO,IAAI,GAAGP,OAAO,CAAC,mBAAD,CAAlB;;AACA,IAAIQ,IAAI,GAAGR,OAAO,CAAC,oCAAD,CAAlB;;AACA,IAAIS,2BAA2B,GAAGT,OAAO,CAAC,6CAAD,CAAzC;;AACA,IAAIU,MAAM,GAAGV,OAAO,CAAC,+BAAD,CAApB,C,CACA;;;AACAA,OAAO,CAAC,2BAAD,CAAP;;AAEA,IAAIW,eAAe,GAAG,UAAUC,iBAAV,EAA6B;AACjD,MAAIC,OAAO,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgBC,CAAhB,EAAmB;AAC/B,QAAI,gBAAgBH,OAApB,EAA6B;AAC3B,cAAQI,SAAS,CAACC,MAAlB;AACE,aAAK,CAAL;AAAQ,iBAAO,IAAIN,iBAAJ,EAAP;;AACR,aAAK,CAAL;AAAQ,iBAAO,IAAIA,iBAAJ,CAAsBE,CAAtB,CAAP;;AACR,aAAK,CAAL;AAAQ,iBAAO,IAAIF,iBAAJ,CAAsBE,CAAtB,EAAyBC,CAAzB,CAAP;AAHV;;AAIE,aAAO,IAAIH,iBAAJ,CAAsBE,CAAtB,EAAyBC,CAAzB,EAA4BC,CAA5B,CAAP;AACH;;AAAC,WAAOf,KAAK,CAACW,iBAAD,EAAoB,IAApB,EAA0BK,SAA1B,CAAZ;AACH,GARD;;AASAJ,EAAAA,OAAO,CAACM,SAAR,GAAoBP,iBAAiB,CAACO,SAAtC;AACA,SAAON,OAAP;AACD,CAZD;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAO,MAAM,CAACC,OAAP,GAAiB,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC1C,MAAIC,MAAM,GAAGF,OAAO,CAACG,MAArB;AACA,MAAIC,MAAM,GAAGJ,OAAO,CAACK,MAArB;AACA,MAAIC,MAAM,GAAGN,OAAO,CAACO,IAArB;AACA,MAAIC,KAAK,GAAGR,OAAO,CAACS,KAApB;AAEA,MAAIC,YAAY,GAAGN,MAAM,GAAG3B,UAAH,GAAgB6B,MAAM,GAAG7B,UAAU,CAACyB,MAAD,CAAb,GAAwBzB,UAAU,CAACyB,MAAD,CAAV,IAAsBzB,UAAU,CAACyB,MAAD,CAAV,CAAmBL,SAAhH;AAEA,MAAIM,MAAM,GAAGC,MAAM,GAAGnB,IAAH,GAAUA,IAAI,CAACiB,MAAD,CAAJ,IAAgBf,2BAA2B,CAACF,IAAD,EAAOiB,MAAP,EAAe,EAAf,CAA3B,CAA8CA,MAA9C,CAA7C;AACA,MAAIS,eAAe,GAAGR,MAAM,CAACN,SAA7B;AAEA,MAAIe,MAAJ,EAAYC,UAAZ,EAAwBC,iBAAxB;AACA,MAAIC,GAAJ,EAASC,cAAT,EAAyBC,cAAzB,EAAyCC,cAAzC,EAAyDC,cAAzD,EAAyEC,UAAzE;;AAEA,OAAKL,GAAL,IAAYd,MAAZ,EAAoB;AAClBW,IAAAA,MAAM,GAAG5B,QAAQ,CAACoB,MAAM,GAAGW,GAAH,GAASb,MAAM,IAAII,MAAM,GAAG,GAAH,GAAS,GAAnB,CAAN,GAAgCS,GAAhD,EAAqDf,OAAO,CAACqB,MAA7D,CAAjB,CADkB,CAElB;;AACAR,IAAAA,UAAU,GAAG,CAACD,MAAD,IAAWF,YAAX,IAA2BtB,MAAM,CAACsB,YAAD,EAAeK,GAAf,CAA9C;AAEAE,IAAAA,cAAc,GAAGd,MAAM,CAACY,GAAD,CAAvB;AAEA,QAAIF,UAAJ,EAAgB,IAAIb,OAAO,CAACsB,cAAZ,EAA4B;AAC1CF,MAAAA,UAAU,GAAGtC,wBAAwB,CAAC4B,YAAD,EAAeK,GAAf,CAArC;AACAG,MAAAA,cAAc,GAAGE,UAAU,IAAIA,UAAU,CAACG,KAA1C;AACD,KAHe,MAGTL,cAAc,GAAGR,YAAY,CAACK,GAAD,CAA7B,CAVW,CAYlB;;AACAC,IAAAA,cAAc,GAAIH,UAAU,IAAIK,cAAf,GAAiCA,cAAjC,GAAkDjB,MAAM,CAACc,GAAD,CAAzE;AAEA,QAAI,CAACH,MAAD,IAAW,CAACJ,KAAZ,IAAqB,OAAOS,cAAP,IAAyB,OAAOD,cAAzD,EAAyE,SAfvD,CAiBlB;;AACA,QAAIhB,OAAO,CAACd,IAAR,IAAgB2B,UAApB,EAAgCM,cAAc,GAAGjC,IAAI,CAAC8B,cAAD,EAAiBvC,UAAjB,CAArB,CAAhC,CACA;AADA,SAEK,IAAIuB,OAAO,CAACwB,IAAR,IAAgBX,UAApB,EAAgCM,cAAc,GAAG9B,eAAe,CAAC2B,cAAD,CAAhC,CAAhC,CACL;AADK,SAEA,IAAIR,KAAK,IAAI3B,UAAU,CAACmC,cAAD,CAAvB,EAAyCG,cAAc,GAAGvC,WAAW,CAACoC,cAAD,CAA5B,CAAzC,CACL;AADK,SAEAG,cAAc,GAAGH,cAAjB,CAxBa,CA0BlB;;AACA,QAAIhB,OAAO,CAACyB,IAAR,IAAiBT,cAAc,IAAIA,cAAc,CAACS,IAAlD,IAA4DR,cAAc,IAAIA,cAAc,CAACQ,IAAjG,EAAwG;AACtGtC,MAAAA,2BAA2B,CAACgC,cAAD,EAAiB,MAAjB,EAAyB,IAAzB,CAA3B;AACD;;AAEDhC,IAAAA,2BAA2B,CAACgB,MAAD,EAASY,GAAT,EAAcI,cAAd,CAA3B;;AAEA,QAAIX,KAAJ,EAAW;AACTM,MAAAA,iBAAiB,GAAGZ,MAAM,GAAG,WAA7B;;AACA,UAAI,CAACd,MAAM,CAACH,IAAD,EAAO6B,iBAAP,CAAX,EAAsC;AACpC3B,QAAAA,2BAA2B,CAACF,IAAD,EAAO6B,iBAAP,EAA0B,EAA1B,CAA3B;AACD,OAJQ,CAKT;;;AACA3B,MAAAA,2BAA2B,CAACF,IAAI,CAAC6B,iBAAD,CAAL,EAA0BC,GAA1B,EAA+BC,cAA/B,CAA3B,CANS,CAOT;;AACA,UAAIhB,OAAO,CAAC0B,IAAR,IAAgBf,eAAhB,KAAoCC,MAAM,IAAI,CAACD,eAAe,CAACI,GAAD,CAA9D,CAAJ,EAA0E;AACxE5B,QAAAA,2BAA2B,CAACwB,eAAD,EAAkBI,GAAlB,EAAuBC,cAAvB,CAA3B;AACD;AACF;AACF;AACF,CA5DD","sourcesContent":["'use strict';\nvar globalThis = require('../internals/global-this');\nvar apply = require('../internals/function-apply');\nvar uncurryThis = require('../internals/function-uncurry-this-clause');\nvar isCallable = require('../internals/is-callable');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar isForced = require('../internals/is-forced');\nvar path = require('../internals/path');\nvar bind = require('../internals/function-bind-context');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar hasOwn = require('../internals/has-own-property');\n// add debugging info\nrequire('../internals/shared-store');\n\nvar wrapConstructor = function (NativeConstructor) {\n  var Wrapper = function (a, b, c) {\n    if (this instanceof Wrapper) {\n      switch (arguments.length) {\n        case 0: return new NativeConstructor();\n        case 1: return new NativeConstructor(a);\n        case 2: return new NativeConstructor(a, b);\n      } return new NativeConstructor(a, b, c);\n    } return apply(NativeConstructor, this, arguments);\n  };\n  Wrapper.prototype = NativeConstructor.prototype;\n  return Wrapper;\n};\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var PROTO = options.proto;\n\n  var nativeSource = GLOBAL ? globalThis : STATIC ? globalThis[TARGET] : globalThis[TARGET] && globalThis[TARGET].prototype;\n\n  var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];\n  var targetPrototype = target.prototype;\n\n  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;\n  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;\n\n  for (key in source) {\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contains in native\n    USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);\n\n    targetProperty = target[key];\n\n    if (USE_NATIVE) if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(nativeSource, key);\n      nativeProperty = descriptor && descriptor.value;\n    } else nativeProperty = nativeSource[key];\n\n    // export native or implementation\n    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];\n\n    if (!FORCED && !PROTO && typeof targetProperty == typeof sourceProperty) continue;\n\n    // bind methods to global for calling from export context\n    if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, globalThis);\n    // wrap global constructors for prevent changes in this version\n    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);\n    // make static versions for prototype methods\n    else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty);\n    // default case\n    else resultProperty = sourceProperty;\n\n    // add a flag to not completely full polyfills\n    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(resultProperty, 'sham', true);\n    }\n\n    createNonEnumerableProperty(target, key, resultProperty);\n\n    if (PROTO) {\n      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';\n      if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {\n        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});\n      }\n      // export virtual prototype methods\n      createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);\n      // export real prototype methods\n      if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {\n        createNonEnumerableProperty(targetPrototype, key, sourceProperty);\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}